// Agent-Ops git isolation â€” generated by @yattalo/task-system
//
// Creates and manages git worktrees for isolated agent execution.
// Each run gets its own worktree to prevent conflicts.

import { execSync } from "node:child_process";
import { existsSync, mkdirSync, rmSync } from "node:fs";
import { join, resolve } from "node:path";
import type { AgentOpsConfig } from "./types.js";

const PROTECTED_BRANCHES = ["main","master"];

export interface WorktreeInfo {
  path: string;
  branch: string;
  baseBranch: string;
}

export function createWorktree(
  config: AgentOpsConfig,
  runId: string,
  baseBranch: string = "main",
): WorktreeInfo {
  const worktreeBase = config.worktreeBase;
  mkdirSync(worktreeBase, { recursive: true });

  const branchName = `agent-ops/${runId}`;
  const worktreePath = join(worktreeBase, runId);

  if (existsSync(worktreePath)) {
    throw new Error(`Worktree already exists: ${worktreePath}`);
  }

  // Validate base branch exists
  try {
    execSync(`git rev-parse --verify ${baseBranch}`, {
      cwd: config.projectRoot,
      stdio: "pipe",
    });
  } catch {
    throw new Error(`Base branch does not exist: ${baseBranch}`);
  }

  // Validate not targeting protected branch directly
  if (PROTECTED_BRANCHES.includes(branchName)) {
    throw new Error(`Cannot create worktree on protected branch: ${branchName}`);
  }

  // Create worktree with new branch
  execSync(
    `git worktree add -b "${branchName}" "${worktreePath}" "${baseBranch}"`,
    { cwd: config.projectRoot, stdio: "pipe" },
  );

  return { path: worktreePath, branch: branchName, baseBranch };
}

export function removeWorktree(config: AgentOpsConfig, runId: string): void {
  const worktreePath = join(config.worktreeBase, runId);

  if (!existsSync(worktreePath)) return;

  try {
    execSync(`git worktree remove "${worktreePath}" --force`, {
      cwd: config.projectRoot,
      stdio: "pipe",
    });
  } catch {
    // Fallback: manual cleanup
    rmSync(worktreePath, { recursive: true, force: true });
    try {
      execSync("git worktree prune", { cwd: config.projectRoot, stdio: "pipe" });
    } catch {}
  }

  // Clean up branch
  const branchName = `agent-ops/${runId}`;
  try {
    execSync(`git branch -D "${branchName}"`, {
      cwd: config.projectRoot,
      stdio: "pipe",
    });
  } catch {}
}

export function getWorktreeGitStats(
  worktreePath: string,
  baseBranch: string,
): { commitCount: number; filesChanged: number; linesAdded: number; linesRemoved: number } {
  try {
    const commitCount = parseInt(
      execSync(`git rev-list --count ${baseBranch}..HEAD`, {
        cwd: worktreePath,
        encoding: "utf-8",
      }).trim(),
      10,
    );

    const diffStat = execSync(`git diff --shortstat ${baseBranch}..HEAD`, {
      cwd: worktreePath,
      encoding: "utf-8",
    }).trim();

    let filesChanged = 0, linesAdded = 0, linesRemoved = 0;
    const filesMatch = diffStat.match(/(\d+) files? changed/);
    const addMatch = diffStat.match(/(\d+) insertions?/);
    const delMatch = diffStat.match(/(\d+) deletions?/);

    if (filesMatch) filesChanged = parseInt(filesMatch[1], 10);
    if (addMatch) linesAdded = parseInt(addMatch[1], 10);
    if (delMatch) linesRemoved = parseInt(delMatch[1], 10);

    return { commitCount, filesChanged, linesAdded, linesRemoved };
  } catch {
    return { commitCount: 0, filesChanged: 0, linesAdded: 0, linesRemoved: 0 };
  }
}

export function listStaleWorktrees(config: AgentOpsConfig, maxAgeMs: number = 24 * 60 * 60 * 1000): string[] {
  const worktreeBase = config.worktreeBase;
  if (!existsSync(worktreeBase)) return [];

  const { readdirSync, statSync } = require("node:fs");
  const now = Date.now();
  const stale: string[] = [];

  for (const entry of readdirSync(worktreeBase)) {
    const entryPath = join(worktreeBase, entry);
    try {
      const stat = statSync(entryPath);
      if (now - stat.mtimeMs > maxAgeMs) {
        stale.push(entry);
      }
    } catch {}
  }

  return stale;
}
