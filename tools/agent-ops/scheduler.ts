// Agent-Ops cron scheduler â€” generated by @yattalo/task-system
//
// Minimal cron parser for Agent-Ops scheduling.
// Supports standard 5-field cron expressions: minute hour day month weekday

export function parseCron(expression: string): { minute: number[]; hour: number[]; day: number[]; month: number[]; weekday: number[] } {
  const parts = expression.trim().split(/\s+/);
  if (parts.length !== 5) throw new Error(`Invalid cron: ${expression}`);

  return {
    minute: parseField(parts[0], 0, 59),
    hour: parseField(parts[1], 0, 23),
    day: parseField(parts[2], 1, 31),
    month: parseField(parts[3], 1, 12),
    weekday: parseField(parts[4], 0, 6),
  };
}

function parseField(field: string, min: number, max: number): number[] {
  if (field === "*") return range(min, max);

  const values = new Set<number>();
  for (const part of field.split(",")) {
    if (part.includes("/")) {
      const [rangeStr, stepStr] = part.split("/");
      const step = parseInt(stepStr, 10);
      const [start, end] = rangeStr === "*" ? [min, max] : rangeStr.split("-").map(Number);
      for (let i = start; i <= (end ?? max); i += step) values.add(i);
    } else if (part.includes("-")) {
      const [start, end] = part.split("-").map(Number);
      for (let i = start; i <= end; i++) values.add(i);
    } else {
      values.add(parseInt(part, 10));
    }
  }
  return [...values].sort((a, b) => a - b);
}

function range(min: number, max: number): number[] {
  return Array.from({ length: max - min + 1 }, (_, i) => min + i);
}

export function getNextRun(expression: string, after: Date = new Date()): Date {
  const cron = parseCron(expression);
  const next = new Date(after.getTime() + 60000); // start from next minute
  next.setSeconds(0, 0);

  for (let attempts = 0; attempts < 525960; attempts++) { // max ~1 year of minutes
    if (
      cron.month.includes(next.getMonth() + 1) &&
      cron.day.includes(next.getDate()) &&
      cron.weekday.includes(next.getDay()) &&
      cron.hour.includes(next.getHours()) &&
      cron.minute.includes(next.getMinutes())
    ) {
      return next;
    }
    next.setTime(next.getTime() + 60000);
  }

  throw new Error(`No next run found for: ${expression}`);
}

export function shouldRunNow(expression: string, lastRunAt?: number): boolean {
  const now = new Date();
  const cron = parseCron(expression);

  const matches =
    cron.month.includes(now.getMonth() + 1) &&
    cron.day.includes(now.getDate()) &&
    cron.weekday.includes(now.getDay()) &&
    cron.hour.includes(now.getHours()) &&
    cron.minute.includes(now.getMinutes());

  if (!matches) return false;
  if (!lastRunAt) return true;

  // Don't run again if already ran this minute
  const lastRun = new Date(lastRunAt);
  return (
    lastRun.getMinutes() !== now.getMinutes() ||
    lastRun.getHours() !== now.getHours() ||
    lastRun.getDate() !== now.getDate()
  );
}
