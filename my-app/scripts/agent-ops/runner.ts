#!/usr/bin/env npx tsx
// ============================================================
// Agent-Ops Runner â€” Main polling loop
// Generated by @yattalo/task-system for my-app
// ============================================================
//
// Usage: npx tsx scripts/agent-ops/runner.ts
//
// This is the main Agent-Ops daemon. It:
// 1. Polls Convex for pending runs every N seconds
// 2. Evaluates scheduled jobs for due runs
// 3. Creates git worktrees for isolation
// 4. Launches agent CLI processes
// 5. Streams logs back to Convex
// 6. Cleans up on completion

import { execSync } from "node:child_process";
import { loadConfig } from "./config.js";
import { shouldRunNow } from "./scheduler.js";
import { acquireLane, releaseLane } from "./lane-queue.js";
import { createWorktree, removeWorktree, getWorktreeGitStats } from "./git-isolation.js";
import { launchAgent } from "./agent-launcher.js";
import { LogStreamer } from "./log-streamer.js";
import { createPR } from "./pr-creator.js";
import { cleanupStaleWorktrees } from "./cleanup.js";
import type { RunContext } from "./types.js";

const config = loadConfig();
let activeRuns = 0;
let totalRunsToday = 0;
let lastCleanup = 0;

function convexRun(fn: string, args?: Record<string, unknown>): string {
  const argsStr = args ? ` '${JSON.stringify(args)}'` : "";
  return execSync(`npx convex run taskSystem/agentOps:${fn}${argsStr}`, {
    cwd: config.projectRoot,
    encoding: "utf-8",
    stdio: ["pipe", "pipe", "pipe"],
  }).trim();
}

async function pollOnce(): Promise<void> {
  // 1. Check for pending runs
  try {
    const pendingRaw = convexRun("getPendingRuns");
    const pendingRuns = JSON.parse(pendingRaw);

    for (const run of pendingRuns) {
      if (activeRuns >= config.maxConcurrentRuns) break;
      if (totalRunsToday >= config.maxRunsPerDay) {
        console.log("[runner] Daily run limit reached");
        break;
      }

      // Check lane availability
      if (run.laneId && !acquireLane(run.laneId, run.runId)) {
        console.log(`[runner] Lane ${run.laneId} busy, skipping ${run.runId}`);
        continue;
      }

      executeRun(run).catch((err) => {
        console.error(`[runner] Run ${run.runId} failed: ${err.message}`);
      });
    }
  } catch (err) {
    console.error(`[runner] Poll error: ${(err as Error).message}`);
  }

  // 2. Evaluate scheduled jobs
  try {
    const jobsRaw = convexRun("listJobs", { enabled: true });
    const jobs = JSON.parse(jobsRaw);

    for (const job of jobs) {
      if (job.scheduleType === "cron" && job.cronExpression) {
        if (shouldRunNow(job.cronExpression, job.lastRunAt)) {
          console.log(`[runner] Scheduling job ${job.jobId}`);
          convexRun("triggerManualRun", { jobId: job.jobId });
        }
      }
    }
  } catch (err) {
    console.error(`[runner] Schedule check error: ${(err as Error).message}`);
  }

  // 3. Periodic cleanup (every hour)
  if (Date.now() - lastCleanup > 3600000) {
    cleanupStaleWorktrees(config);
    lastCleanup = Date.now();
  }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function executeRun(run: any): Promise<void> {
  activeRuns++;
  totalRunsToday++;
  const logStreamer = new LogStreamer(run.runId, config.projectRoot);

  try {
    // Update status to provisioning
    convexRun("updateRunStatus", { runId: run.runId, status: "provisioning" });

    // Create worktree
    const baseBranch = run.baseBranch ?? "main";
    const worktree = createWorktree(config, run.runId, baseBranch);
    convexRun("updateRunGitInfo", {
      runId: run.runId,
      worktreePath: worktree.path,
      branchName: worktree.branch,
    });

    // Update status to running
    convexRun("updateRunStatus", { runId: run.runId, status: "running" });

    // Start log streaming
    logStreamer.start();

    const runCtx: RunContext = {
      runId: run.runId,
      jobId: run.jobId,
      agent: run.agent,
      prompt: run.prompt,
      executionMode: run.executionMode,
      worktreePath: worktree.path,
      branchName: worktree.branch,
      baseBranch,
      startedAt: Date.now(),
    };

    // Launch agent
    const { exitCode } = launchAgent(config, runCtx, (entry) => logStreamer.push(entry));
    const code = await exitCode;

    // Collect git stats
    const stats = getWorktreeGitStats(worktree.path, baseBranch);
    convexRun("updateRunGitInfo", { runId: run.runId, ...stats });

    // Create PR if configured
    let prUrl: string | undefined;
    let prNumber: number | undefined;

    // Get job config for PR creation
    try {
      const jobRaw = convexRun("getJob", { jobId: run.jobId });
      const job = JSON.parse(jobRaw);
      if (job.createPR && stats.commitCount > 0) {
        const pr = createPR(runCtx, `Job ${run.jobId} completed`);
        if (pr) {
          prUrl = pr.url;
          prNumber = pr.number;
        }
      }
    } catch {}

    // Complete run
    const status = code === 0 ? "success" : "failed";
    convexRun("completeRun", {
      runId: run.runId,
      status,
      exitCode: code,
      summary: `Agent ${run.agent} exited with code ${code}. ${stats.commitCount} commits, ${stats.filesChanged} files changed.`,
      ...(prUrl ? { prUrl, prNumber } : {}),
    });

    // Cleanup worktree (keep if PR was created)
    if (!prUrl) {
      removeWorktree(config, run.runId);
    }
  } catch (err) {
    convexRun("completeRun", {
      runId: run.runId,
      status: "failed",
      error: (err as Error).message,
    });
  } finally {
    logStreamer.stop();
    activeRuns--;
    if (run.laneId) releaseLane(run.laneId, run.runId);
  }
}

// Main loop
console.log("[agent-ops] Starting runner...");
console.log(`[agent-ops] Poll interval: ${config.pollInterval}ms`);
console.log(`[agent-ops] Max concurrent: ${config.maxConcurrentRuns}`);

setInterval(pollOnce, config.pollInterval);
pollOnce(); // Run immediately
