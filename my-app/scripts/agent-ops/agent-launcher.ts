// Agent-Ops agent launcher â€” generated by @yattalo/task-system
//
// Spawns agent CLI processes (claude, gemini, codex) with proper environment.

import { spawn, ChildProcess } from "node:child_process";
import type { AgentOpsConfig, RunContext, LogEntry } from "./types.js";

export interface LaunchResult {
  process: ChildProcess;
  exitCode: Promise<number>;
}

export function launchAgent(
  config: AgentOpsConfig,
  run: RunContext,
  onLog: (entry: LogEntry) => void,
): LaunchResult {
  const agentCmd = config.agentCommands[run.agent];
  if (!agentCmd) {
    throw new Error(`No command configured for agent: ${run.agent}`);
  }

  const timeoutMs = (config.defaultTimeoutMinutes ?? 30) * 60 * 1000;

  // Build agent-specific args
  const args = buildAgentArgs(run);

  onLog({
    timestamp: Date.now(),
    level: "info",
    message: `Launching ${run.agent}: ${agentCmd} ${args.join(" ")}`,
  });

  const proc = spawn(agentCmd, args, {
    cwd: run.worktreePath,
    env: {
      ...process.env,
      AGENT_OPS_RUN_ID: run.runId,
      AGENT_OPS_JOB_ID: run.jobId,
    },
    stdio: ["pipe", "pipe", "pipe"],
  });

  // Stream stdout/stderr to log callback
  proc.stdout?.on("data", (data: Buffer) => {
    const text = data.toString().trim();
    if (text) {
      onLog({ timestamp: Date.now(), level: "info", message: text.slice(0, 500) });
    }
  });

  proc.stderr?.on("data", (data: Buffer) => {
    const text = data.toString().trim();
    if (text) {
      onLog({ timestamp: Date.now(), level: "warn", message: text.slice(0, 500) });
    }
  });

  // Timeout handling
  const timeoutId = setTimeout(() => {
    onLog({ timestamp: Date.now(), level: "error", message: `Timeout after ${config.defaultTimeoutMinutes}min` });
    proc.kill("SIGTERM");
    setTimeout(() => proc.kill("SIGKILL"), 5000);
  }, timeoutMs);

  const exitCode = new Promise<number>((resolve) => {
    proc.on("close", (code) => {
      clearTimeout(timeoutId);
      resolve(code ?? 1);
    });
    proc.on("error", (err) => {
      clearTimeout(timeoutId);
      onLog({ timestamp: Date.now(), level: "error", message: `Process error: ${err.message}` });
      resolve(1);
    });
  });

  return { process: proc, exitCode };
}

function buildAgentArgs(run: RunContext): string[] {
  switch (run.agent) {
    case "claude":
      return ["--print", "--dangerously-skip-permissions", "-p", run.prompt];
    case "gemini":
      return ["--prompt", run.prompt];
    case "codex":
      return ["--prompt", run.prompt, "--approval-mode", "full-auto"];
    default:
      return [run.prompt];
  }
}
