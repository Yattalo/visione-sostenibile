// ============================================================
// Agent-Ops Backend — generated by @yattalo/task-system
// Project: my-app
// ============================================================

import { v } from "convex/values";
import { query, mutation } from "../_generated/server";

const DEFAULT_PROJECT_ID = "visione-sostenibile" as const;

function resolveProjectId(projectId?: string): string {
  return projectId ?? DEFAULT_PROJECT_ID;
}

const SCHEDULE_TYPE = v.union(v.literal("cron"), v.literal("interval"), v.literal("one-shot"), v.literal("trigger"));
const AGENT_TYPE = v.union(v.literal("claude"), v.literal("gemini"), v.literal("codex"));
const EXEC_MODE = v.union(v.literal("isolated"), v.literal("read-only"), v.literal("dry-run"));
const RUN_STATUS = v.union(v.literal("queued"), v.literal("provisioning"), v.literal("running"), v.literal("completing"), v.literal("success"), v.literal("failed"), v.literal("timeout"), v.literal("cancelled"));
const TRIGGERED_BY = v.union(v.literal("schedule"), v.literal("trigger"), v.literal("manual"), v.literal("retry"));

// ══════════════════════════════════════════════════════════════
// QUERIES
// ══════════════════════════════════════════════════════════════

export const listJobs = query({
  args: { enabled: v.optional(v.boolean()), agent: v.optional(AGENT_TYPE), scheduleType: v.optional(SCHEDULE_TYPE), projectId: v.optional(v.string()) },
  handler: async (ctx, args) => {
    const scope = resolveProjectId(args.projectId);
    let jobs = await ctx.db.query("agentOpsJobs").withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
    if (args.enabled !== undefined) jobs = jobs.filter((j) => j.enabled === args.enabled);
    if (args.agent) jobs = jobs.filter((j) => j.agent === args.agent);
    if (args.scheduleType) jobs = jobs.filter((j) => j.scheduleType === args.scheduleType);
    return jobs.sort((a, b) => b.updatedAt - a.updatedAt);
  },
});

export const getJob = query({
  args: { jobId: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { jobId, projectId }) => {
    const scope = resolveProjectId(projectId);
    return ctx.db.query("agentOpsJobs").withIndex("by_project_jobId", (q) => q.eq("projectId", scope).eq("jobId", jobId)).unique();
  },
});

export const getDashboardStats = query({
  args: { projectId: v.optional(v.string()) },
  handler: async (ctx, { projectId }) => {
    const scope = resolveProjectId(projectId);
    const jobs = await ctx.db.query("agentOpsJobs").withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
    const runs = await ctx.db.query("agentOpsRuns").withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
    const byStatus: Record<string, number> = {};
    for (const r of runs) byStatus[r.status] = (byStatus[r.status] ?? 0) + 1;
    return {
      totalJobs: jobs.length,
      enabledJobs: jobs.filter((j) => j.enabled).length,
      totalRuns: runs.length,
      byStatus,
      recentRuns: runs.sort((a, b) => b.queuedAt - a.queuedAt).slice(0, 10),
    };
  },
});

export const listRuns = query({
  args: { jobId: v.optional(v.string()), status: v.optional(RUN_STATUS), agent: v.optional(AGENT_TYPE), limit: v.optional(v.number()), projectId: v.optional(v.string()) },
  handler: async (ctx, args) => {
    const scope = resolveProjectId(args.projectId);
    let runs = await ctx.db.query("agentOpsRuns").withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
    if (args.jobId) runs = runs.filter((r) => r.jobId === args.jobId);
    if (args.status) runs = runs.filter((r) => r.status === args.status);
    if (args.agent) runs = runs.filter((r) => r.agent === args.agent);
    runs.sort((a, b) => b.queuedAt - a.queuedAt);
    return args.limit ? runs.slice(0, args.limit) : runs;
  },
});

export const getRun = query({
  args: { runId: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { runId, projectId }) => {
    const scope = resolveProjectId(projectId);
    return ctx.db.query("agentOpsRuns").withIndex("by_project_runId", (q) => q.eq("projectId", scope).eq("runId", runId)).unique();
  },
});

export const getRunLogs = query({
  args: { runId: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { runId, projectId }) => {
    const scope = resolveProjectId(projectId);
    const run = await ctx.db.query("agentOpsRuns").withIndex("by_project_runId", (q) => q.eq("projectId", scope).eq("runId", runId)).unique();
    return run?.logs ?? [];
  },
});

export const getPendingRuns = query({
  args: { projectId: v.optional(v.string()) },
  handler: async (ctx, { projectId }) => {
    const scope = resolveProjectId(projectId);
    const queued = await ctx.db.query("agentOpsRuns").withIndex("by_project_status", (q) => q.eq("projectId", scope).eq("status", "queued")).collect();
    const prov = await ctx.db.query("agentOpsRuns").withIndex("by_project_status", (q) => q.eq("projectId", scope).eq("status", "provisioning")).collect();
    return [...queued, ...prov].sort((a, b) => a.queuedAt - b.queuedAt);
  },
});

// ══════════════════════════════════════════════════════════════
// MUTATIONS
// ══════════════════════════════════════════════════════════════

export const createJob = mutation({
  args: {
    projectId: v.optional(v.string()),
    jobId: v.string(), name: v.string(), description: v.optional(v.string()),
    scheduleType: SCHEDULE_TYPE, cronExpression: v.optional(v.string()),
    intervalSeconds: v.optional(v.number()), timezone: v.optional(v.string()),
    triggerType: v.optional(v.string()), triggerFilter: v.optional(v.any()),
    agent: AGENT_TYPE, prompt: v.string(), executionMode: EXEC_MODE,
    createPR: v.boolean(), prBaseBranch: v.optional(v.string()),
    maxDurationMinutes: v.optional(v.number()), laneId: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const scope = resolveProjectId(args.projectId);
    const now = Date.now();
    return await ctx.db.insert("agentOpsJobs", {
      ...args, projectId: scope, enabled: true, totalRuns: 0, successfulRuns: 0, failedRuns: 0, createdAt: now, updatedAt: now,
    });
  },
});

export const updateJob = mutation({
  args: { jobId: v.string(), fields: v.any(), projectId: v.optional(v.string()) },
  handler: async (ctx, { jobId, fields, projectId }) => {
    const scope = resolveProjectId(projectId);
    const job = await ctx.db.query("agentOpsJobs").withIndex("by_project_jobId", (q) => q.eq("projectId", scope).eq("jobId", jobId)).unique();
    if (!job) throw new Error(`Job ${jobId} not found`);
    await ctx.db.patch(job._id, { ...fields, projectId: scope, updatedAt: Date.now() });
  },
});

export const toggleJob = mutation({
  args: { jobId: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { jobId, projectId }) => {
    const scope = resolveProjectId(projectId);
    const job = await ctx.db.query("agentOpsJobs").withIndex("by_project_jobId", (q) => q.eq("projectId", scope).eq("jobId", jobId)).unique();
    if (!job) throw new Error(`Job ${jobId} not found`);
    await ctx.db.patch(job._id, { enabled: !job.enabled, updatedAt: Date.now() });
  },
});

export const deleteJob = mutation({
  args: { jobId: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { jobId, projectId }) => {
    const scope = resolveProjectId(projectId);
    const job = await ctx.db.query("agentOpsJobs").withIndex("by_project_jobId", (q) => q.eq("projectId", scope).eq("jobId", jobId)).unique();
    if (!job) throw new Error(`Job ${jobId} not found`);
    await ctx.db.delete(job._id);
  },
});

export const createRun = mutation({
  args: {
    projectId: v.optional(v.string()),
    runId: v.string(), jobId: v.string(), agent: AGENT_TYPE, prompt: v.string(),
    executionMode: v.string(), triggeredBy: TRIGGERED_BY,
    triggerContext: v.optional(v.any()), baseBranch: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const scope = resolveProjectId(args.projectId);
    return await ctx.db.insert("agentOpsRuns", {
      ...args, projectId: scope, status: "queued", queuedAt: Date.now(), logs: [],
    });
  },
});

export const updateRunStatus = mutation({
  args: { runId: v.string(), status: RUN_STATUS, projectId: v.optional(v.string()) },
  handler: async (ctx, { runId, status, projectId }) => {
    const scope = resolveProjectId(projectId);
    const run = await ctx.db.query("agentOpsRuns").withIndex("by_project_runId", (q) => q.eq("projectId", scope).eq("runId", runId)).unique();
    if (!run) throw new Error(`Run ${runId} not found`);
    const patch: Record<string, unknown> = { status };
    if (status === "running" && !run.startedAt) patch.startedAt = Date.now();
    if (["success", "failed", "timeout", "cancelled"].includes(status)) patch.completedAt = Date.now();
    await ctx.db.patch(run._id, patch);
  },
});

export const appendRunLog = mutation({
  args: {
    projectId: v.optional(v.string()),
    runId: v.string(),
    entries: v.array(v.object({ timestamp: v.number(), level: v.union(v.literal("info"), v.literal("warn"), v.literal("error"), v.literal("debug")), message: v.string() })),
  },
  handler: async (ctx, { runId, entries, projectId }) => {
    const scope = resolveProjectId(projectId);
    const run = await ctx.db.query("agentOpsRuns").withIndex("by_project_runId", (q) => q.eq("projectId", scope).eq("runId", runId)).unique();
    if (!run) return;
    await ctx.db.patch(run._id, { logs: [...run.logs, ...entries] });
  },
});

export const updateRunGitInfo = mutation({
  args: {
    projectId: v.optional(v.string()),
    runId: v.string(),
    worktreePath: v.optional(v.string()), branchName: v.optional(v.string()),
    commitCount: v.optional(v.number()), filesChanged: v.optional(v.number()),
    linesAdded: v.optional(v.number()), linesRemoved: v.optional(v.number()),
  },
  handler: async (ctx, { runId, projectId, ...info }) => {
    const scope = resolveProjectId(projectId);
    const run = await ctx.db.query("agentOpsRuns").withIndex("by_project_runId", (q) => q.eq("projectId", scope).eq("runId", runId)).unique();
    if (!run) return;
    const patch: Record<string, unknown> = {};
    for (const [k, val] of Object.entries(info)) { if (val !== undefined) patch[k] = val; }
    await ctx.db.patch(run._id, patch);
  },
});

export const completeRun = mutation({
  args: {
    projectId: v.optional(v.string()),
    runId: v.string(), status: v.union(v.literal("success"), v.literal("failed")),
    summary: v.optional(v.string()), error: v.optional(v.string()),
    exitCode: v.optional(v.number()), prUrl: v.optional(v.string()), prNumber: v.optional(v.number()),
  },
  handler: async (ctx, { runId, status, projectId, ...rest }) => {
    const scope = resolveProjectId(projectId);
    const run = await ctx.db.query("agentOpsRuns").withIndex("by_project_runId", (q) => q.eq("projectId", scope).eq("runId", runId)).unique();
    if (!run) throw new Error(`Run ${runId} not found`);
    const now = Date.now();
    const patch: Record<string, unknown> = { status, completedAt: now };
    for (const [k, val] of Object.entries(rest)) { if (val !== undefined) patch[k] = val; }
    await ctx.db.patch(run._id, patch);

    // Update job stats
    const job = await ctx.db.query("agentOpsJobs").withIndex("by_project_jobId", (q) => q.eq("projectId", run.projectId).eq("jobId", run.jobId)).unique();
    if (job) {
      const statPatch: Record<string, unknown> = { lastRunAt: now, updatedAt: now };
      if (status === "success") statPatch.successfulRuns = job.successfulRuns + 1;
      if (status === "failed") statPatch.failedRuns = job.failedRuns + 1;
      await ctx.db.patch(job._id, statPatch);
    }
  },
});

export const cancelRun = mutation({
  args: { runId: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { runId, projectId }) => {
    const scope = resolveProjectId(projectId);
    const run = await ctx.db.query("agentOpsRuns").withIndex("by_project_runId", (q) => q.eq("projectId", scope).eq("runId", runId)).unique();
    if (!run) throw new Error(`Run ${runId} not found`);
    await ctx.db.patch(run._id, { status: "cancelled", completedAt: Date.now() });
  },
});

export const triggerManualRun = mutation({
  args: { jobId: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { jobId, projectId }) => {
    const scope = resolveProjectId(projectId);
    const job = await ctx.db.query("agentOpsJobs").withIndex("by_project_jobId", (q) => q.eq("projectId", scope).eq("jobId", jobId)).unique();
    if (!job) throw new Error(`Job ${jobId} not found`);
    const now = Date.now();
    const runId = `${jobId}-manual-${now}`;
    await ctx.db.insert("agentOpsRuns", {
      projectId: scope,
      runId, jobId, status: "queued", agent: job.agent, prompt: job.prompt,
      executionMode: job.executionMode, queuedAt: now, triggeredBy: "manual",
      baseBranch: job.prBaseBranch,
      logs: [{ timestamp: now, level: "info", message: "Manual trigger" }],
    });
    await ctx.db.patch(job._id, { totalRuns: job.totalRuns + 1, updatedAt: now });
    return runId;
  },
});
