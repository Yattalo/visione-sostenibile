// ============================================================
// Task System Orchestrator — generated by @yattalo/task-system
// Project: my-app | Table: agentTasks
// ============================================================

import { v } from "convex/values";
import { query, mutation } from "../_generated/server";
import { TASK_DEFINITIONS } from "./taskDefinitions";

const TABLE = "agentTasks" as const;
const DEFAULT_PROJECT_ID = "visione-sostenibile" as const;

function resolveProjectId(projectId?: string): string {
  return projectId ?? DEFAULT_PROJECT_ID;
}

// ══════════════════════════════════════════════════════════════
// SEED — Idempotent import from TASK_DEFINITIONS
// ══════════════════════════════════════════════════════════════

export const seed = mutation({
  args: { projectId: v.optional(v.string()) },
  handler: async (ctx, { projectId }) => {
    const scope = resolveProjectId(projectId);
    const existing = await ctx.db.query(TABLE).withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
    const existingIds = new Set(existing.map((t) => t.taskId));
    let created = 0, skipped = 0;
    const now = Date.now();

    for (const def of TASK_DEFINITIONS) {
      if (existingIds.has(def.taskId)) { skipped++; continue; }

      // Check dependencies for auto-blocking
      const deps = def.dependencies ?? [];
      let initStatus = def.status ?? "todo";
      if (deps.length > 0) {
        const unmet = deps.some((d) => !existingIds.has(d) || !existing.find((e) => e.taskId === d && e.status === "done"));
        if (unmet) initStatus = "blocked";
      }

      await ctx.db.insert(TABLE, {
        projectId: scope,
        taskId: def.taskId,
        agent: def.agent as any,
        title: def.title,
        description: def.description,
        priority: (def.priority ?? "medium") as any,
        status: initStatus as any,
        category: def.category as any,
        phaseId: def.phaseId as any,
        wave: def.wave ?? 1,
        estimatedHours: def.estimatedHours,
        dependencies: deps,
        tags: def.tags,
        acceptanceCriteria: def.acceptanceCriteria,
        filesExpected: def.filesExpected ?? [],
        commits: [],
        statusHistory: [{ status: initStatus, timestamp: now }],
        createdAt: now,
        updatedAt: now,
      });
      created++;
      existingIds.add(def.taskId);
    }

    await ctx.db.insert("taskSyncLog", {
      projectId: scope,
      operation: "import", source: "seed", tasksAffected: created + skipped,
      tasksCreated: created, timestamp: now,
    });

    return { created, skipped, total: TASK_DEFINITIONS.length };
  },
});

// ══════════════════════════════════════════════════════════════
// QUERIES
// ══════════════════════════════════════════════════════════════

export const list = query({
  args: { projectId: v.optional(v.string()) },
  handler: async (ctx, { projectId }) => {
    const scope = resolveProjectId(projectId);
    const tasks = await ctx.db.query(TABLE).withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
    const order: Record<string, number> = { critical: 0, high: 1, medium: 2, low: 3 };
    return tasks.sort((a, b) => {
      if (a.wave !== b.wave) return a.wave - b.wave;
      return (order[a.priority] ?? 99) - (order[b.priority] ?? 99) || a.taskId.localeCompare(b.taskId);
    });
  },
});

export const get = query({
  args: { taskId: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { taskId, projectId }) => {
    const scope = resolveProjectId(projectId);
    return await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId)).unique();
  },
});

export const getByAgent = query({
  args: { agent: v.union(v.literal("claude"), v.literal("gemini"), v.literal("codex")), projectId: v.optional(v.string()) },
  handler: async (ctx, { agent, projectId }) => {
    const scope = resolveProjectId(projectId);
    const tasks = await ctx.db.query(TABLE).withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
    const filtered = tasks.filter((t) => t.agent === agent);
    return {
      tasks: filtered,
      stats: {
        total: filtered.length,
        done: filtered.filter((t) => t.status === "done").length,
        inProgress: filtered.filter((t) => t.status === "in_progress").length,
        blocked: filtered.filter((t) => t.status === "blocked").length,
        todo: filtered.filter((t) => t.status === "todo").length,
      },
    };
  },
});

export const getKanban = query({
  args: { projectId: v.optional(v.string()) },
  handler: async (ctx, { projectId }) => {
    const scope = resolveProjectId(projectId);
    const all = await ctx.db.query(TABLE).withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
    return {
      backlog: all.filter((t) => t.status === "backlog" || t.status === "pending"),
      todo: all.filter((t) => t.status === "todo"),
      in_progress: all.filter((t) => t.status === "in_progress"),
      in_review: all.filter((t) => t.status === "in_review"),
      blocked: all.filter((t) => t.status === "blocked"),
      done: all.filter((t) => t.status === "done"),
      cancelled: all.filter((t) => t.status === "cancelled"),
    };
  },
});

export const checkDependencies = query({
  args: { taskId: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { taskId, projectId }) => {
    const scope = resolveProjectId(projectId);
    const task = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId)).unique();
    if (!task?.dependencies?.length) return { canStart: true, unmetDependencies: [] as string[] };
    const unmet: string[] = [];
    for (const d of task.dependencies) {
      const dep = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", d)).unique();
      if (!dep || dep.status !== "done") unmet.push(d);
    }
    return { canStart: unmet.length === 0, unmetDependencies: unmet };
  },
});

export const getStats = query({
  args: { projectId: v.optional(v.string()) },
  handler: async (ctx, { projectId }) => {
    const scope = resolveProjectId(projectId);
    const all = await ctx.db.query(TABLE).withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
    const byStatus: Record<string, number> = {};
    const byAgent: Record<string, number> = {};
    const byWave: Record<number, number> = {};
    let done = 0;
    for (const t of all) {
      byStatus[t.status] = (byStatus[t.status] ?? 0) + 1;
      byAgent[t.agent] = (byAgent[t.agent] ?? 0) + 1;
      byWave[t.wave] = (byWave[t.wave] ?? 0) + 1;
      if (t.status === "done") done++;
    }
    return { total: all.length, done, byStatus, byAgent, byWave, percentComplete: all.length ? Math.round((done / all.length) * 100) : 0 };
  },
});

export const generateReport = query({
  args: { scope: v.optional(v.string()), projectId: v.optional(v.string()) },
  handler: async (ctx, { scope, projectId }) => {
    const projectScope = resolveProjectId(projectId);
    let all = await ctx.db.query(TABLE).withIndex("by_projectId", (q) => q.eq("projectId", projectScope)).collect();
    if (scope) all = all.filter((t) => t.agent === scope);
    const byStatus: Record<string, typeof all> = {};
    for (const t of all) { (byStatus[t.status] ??= []).push(t); }
    const done = all.filter((t) => t.status === "done").length;
    return {
      stats: { total: all.length, done, percentComplete: all.length ? Math.round((done / all.length) * 100) : 0 },
      byStatus,
    };
  },
});

// ══════════════════════════════════════════════════════════════
// MUTATIONS
// ══════════════════════════════════════════════════════════════

export const updateStatus = mutation({
  args: { taskId: v.string(), newStatus: v.string(), note: v.optional(v.string()), agent: v.optional(v.string()), projectId: v.optional(v.string()) },
  handler: async (ctx, { taskId, newStatus, note, agent, projectId }) => {
    const scope = resolveProjectId(projectId);
    const task = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId)).unique();
    if (!task) throw new Error(`Task ${taskId} not found`);
    const now = Date.now();
    const history = [...(task.statusHistory ?? []), { status: newStatus, timestamp: now, note, agent }];
    const patch: Record<string, unknown> = { status: newStatus, statusHistory: history, updatedAt: now };
    if (newStatus === "in_progress" && !task.startedAt) patch.startedAt = now;
    if (newStatus === "done") patch.completedAt = now;
    await ctx.db.patch(task._id, patch);

    if (newStatus === "done") {
      const all = await ctx.db.query(TABLE).withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
      for (const t of all) {
        if (t.status !== "blocked" || !t.dependencies?.includes(taskId)) continue;
        const allMet = t.dependencies.every((d) => d === taskId || all.find((x) => x.taskId === d)?.status === "done");
        if (allMet) await ctx.db.patch(t._id, { status: "todo", updatedAt: now });
      }
    }
  },
});

export const reset = mutation({
  args: { projectId: v.optional(v.string()) },
  handler: async (ctx, { projectId }) => {
    const scope = resolveProjectId(projectId);
    const all = await ctx.db.query(TABLE).withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
    for (const t of all) await ctx.db.delete(t._id);
    await ctx.db.insert("taskSyncLog", { projectId: scope, operation: "import", source: "reset", tasksAffected: all.length, tasksDeleted: all.length, timestamp: Date.now() });
    return { deleted: all.length };
  },
});

// ══════════════════════════════════════════════════════════════
// SOFTWARE EXTENSIONS
// ══════════════════════════════════════════════════════════════

export const flagScopeCreep = mutation({
  args: { taskId: v.string(), flag: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { taskId, flag, projectId }) => {
    const scope = resolveProjectId(projectId);
    const task = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId)).unique();
    if (!task) throw new Error(`Task ${taskId} not found`);
    const flags = [...(task.scopeCreepFlags ?? []), flag];
    await ctx.db.patch(task._id, { scopeCreepFlags: flags, updatedAt: Date.now() });
  },
});

export const setReviewFindings = mutation({
  args: { taskId: v.string(), findings: v.object({ critical: v.number(), high: v.number(), medium: v.number(), low: v.number(), info: v.number() }), projectId: v.optional(v.string()) },
  handler: async (ctx, { taskId, findings, projectId }) => {
    const scope = resolveProjectId(projectId);
    const task = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId)).unique();
    if (!task) throw new Error(`Task ${taskId} not found`);
    await ctx.db.patch(task._id, { reviewFindings: findings, updatedAt: Date.now() });
  },
});
