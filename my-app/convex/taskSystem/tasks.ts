// ============================================================
// Task System CRUD — generated by @yattalo/task-system
// Project: my-app | Table: agentTasks
// ============================================================

import { v } from "convex/values";
import { query, mutation } from "../_generated/server";

const TABLE = "agentTasks" as const;
const DEFAULT_PROJECT_ID = "visione-sostenibile" as const;

function resolveProjectId(projectId?: string): string {
  return projectId ?? DEFAULT_PROJECT_ID;
}

// ── AgentOps Trigger Helper ──

async function checkAgentOpsTriggers(
  ctx: { db: any },
  projectId: string,
  eventType: string,
  eventData: Record<string, unknown>,
) {
  const triggerJobs = await ctx.db
    .query("agentOpsJobs")
    .withIndex("by_scheduleType", (q: any) => q.eq("scheduleType", "trigger"))
    .collect();

  const enabled = triggerJobs.filter((j: any) => {
    if (!j.enabled || j.triggerType !== eventType) return false;
    if (!j.projectId) return false;
    return j.projectId === projectId;
  });

  for (const job of enabled) {
    const filter = job.triggerFilter as Record<string, unknown> | undefined;
    if (filter) {
      const matches = Object.entries(filter).every(([k, val]) => eventData[k] === val);
      if (!matches) continue;
    }
    const now = Date.now();
    await ctx.db.insert("agentOpsRuns", {
      projectId,
      runId: `${job.jobId}-trigger-${now}`,
      jobId: job.jobId,
      status: "queued",
      agent: job.agent,
      prompt: job.prompt,
      executionMode: job.executionMode,
      queuedAt: now,
      triggeredBy: "trigger",
      triggerContext: { event: eventType, ...eventData },
      baseBranch: job.prBaseBranch,
      logs: [{ timestamp: now, level: "info", message: `Triggered by ${eventType}` }],
    });
    await ctx.db.patch(job._id, { lastRunAt: now, totalRuns: job.totalRuns + 1, updatedAt: now });
  }
}

// ══════════════════════════════════════════════════════════════
// QUERIES
// ══════════════════════════════════════════════════════════════

export const get = query({
  args: { taskId: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { taskId, projectId }) => {
    const scope = resolveProjectId(projectId);
    return await ctx.db
      .query(TABLE)
      .withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId))
      .unique();
  },
});

export const getById = query({
  args: { id: v.id(TABLE), projectId: v.optional(v.string()) },
  handler: async (ctx, { id, projectId }) => {
    const task = await ctx.db.get(id);
    if (!task) return null;
    const scope = resolveProjectId(projectId);
    return task.projectId === scope ? task : null;
  },
});

export const list = query({
  args: {
    projectId: v.optional(v.string()),
    agent: v.optional(v.union(v.literal("claude"), v.literal("gemini"), v.literal("codex"))),
    status: v.optional(v.string()),
    priority: v.optional(v.string()),
    wave: v.optional(v.number()),
    category: v.optional(v.string()),
    phaseId: v.optional(v.string()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const scope = resolveProjectId(args.projectId);
    let tasks = await ctx.db.query(TABLE).withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
    if (args.agent) tasks = tasks.filter((t) => t.agent === args.agent);
    if (args.status) tasks = tasks.filter((t) => t.status === args.status);
    if (args.priority) tasks = tasks.filter((t) => t.priority === args.priority);
    if (args.wave !== undefined) tasks = tasks.filter((t) => t.wave === args.wave);
    if (args.category) tasks = tasks.filter((t) => t.category === args.category);
    if (args.phaseId) tasks = tasks.filter((t) => t.phaseId === args.phaseId);
    const order: Record<string, number> = { critical: 0, high: 1, medium: 2, low: 3 };
    tasks.sort((a, b) => {
      if (a.wave !== b.wave) return a.wave - b.wave;
      const ap = order[a.priority] ?? 99, bp = order[b.priority] ?? 99;
      if (ap !== bp) return ap - bp;
      return a.taskId.localeCompare(b.taskId);
    });
    return args.limit ? tasks.slice(0, args.limit) : tasks;
  },
});

export const getKanban = query({
  args: { projectId: v.optional(v.string()) },
  handler: async (ctx, { projectId }) => {
    const scope = resolveProjectId(projectId);
    const all = await ctx.db.query(TABLE).withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
    return {
      backlog: all.filter((t) => t.status === "backlog" || t.status === "pending"),
      todo: all.filter((t) => t.status === "todo"),
      in_progress: all.filter((t) => t.status === "in_progress"),
      in_review: all.filter((t) => t.status === "in_review"),
      blocked: all.filter((t) => t.status === "blocked"),
      done: all.filter((t) => t.status === "done"),
      cancelled: all.filter((t) => t.status === "cancelled"),
    };
  },
});

export const getBlockedTasks = query({
  args: { taskId: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { taskId, projectId }) => {
    const scope = resolveProjectId(projectId);
    const task = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId)).unique();
    if (!task?.blocks?.length) return [];
    const results = [];
    for (const id of task.blocks) {
      const t = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", id)).unique();
      if (t) results.push(t);
    }
    return results;
  },
});

export const search = query({
  args: { query: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { query: q, projectId }) => {
    const scope = resolveProjectId(projectId);
    const all = await ctx.db.query(TABLE).withIndex("by_projectId", (q2) => q2.eq("projectId", scope)).collect();
    const lq = q.toLowerCase();
    return all.filter((t) =>
      t.title.toLowerCase().includes(lq) ||
      t.taskId.toLowerCase().includes(lq) ||
      (t.description ?? "").toLowerCase().includes(lq) ||
      (t.tags ?? []).some((tag) => tag.toLowerCase().includes(lq))
    );
  },
});

export const getStats = query({
  args: { projectId: v.optional(v.string()) },
  handler: async (ctx, { projectId }) => {
    const scope = resolveProjectId(projectId);
    const all = await ctx.db.query(TABLE).withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
    const byStatus: Record<string, number> = {};
    const byAgent: Record<string, number> = {};
    let done = 0;
    for (const t of all) {
      byStatus[t.status] = (byStatus[t.status] ?? 0) + 1;
      byAgent[t.agent] = (byAgent[t.agent] ?? 0) + 1;
      if (t.status === "done") done++;
    }
    return { total: all.length, byStatus, byAgent, done };
  },
});


export const checkDependencies = query({
  args: { taskId: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { taskId, projectId }) => {
    const scope = resolveProjectId(projectId);
    const task = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId)).unique();
    if (!task?.dependencies?.length) return { canStart: true, unmetDependencies: [] as string[], blockingTasks: [] as any[] };
    const unmet: string[] = [];
    const blocking: any[] = [];
    for (const depId of task.dependencies) {
      const dep = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", depId)).unique();
      if (!dep || dep.status !== "done") { unmet.push(depId); if (dep) blocking.push(dep); }
    }
    return { canStart: unmet.length === 0, unmetDependencies: unmet, blockingTasks: blocking };
  },
});

// ══════════════════════════════════════════════════════════════
// MUTATIONS
// ══════════════════════════════════════════════════════════════

export const create = mutation({
  args: {
    projectId: v.optional(v.string()),
    taskId: v.string(),
    agent: v.union(v.literal("claude"), v.literal("gemini"), v.literal("codex")),
    title: v.string(),
    description: v.optional(v.string()),
    priority: v.optional(v.union(v.literal("critical"), v.literal("high"), v.literal("medium"), v.literal("low"))),
    status: v.optional(v.string()),
    category: v.optional(v.string()),
    phaseId: v.optional(v.string()),
    wave: v.optional(v.number()),
    estimatedHours: v.optional(v.number()),
    dependencies: v.optional(v.array(v.string())),
    tags: v.optional(v.array(v.string())),
    acceptanceCriteria: v.optional(v.array(v.string())),
    filesExpected: v.optional(v.array(v.string())),
  },
  handler: async (ctx, args) => {
    const projectId = resolveProjectId(args.projectId);
    const now = Date.now();
    const deps = args.dependencies ?? [];
    let initStatus = args.status ?? "todo";

    // Auto-block if unmet dependencies
    if (deps.length > 0) {
      for (const depId of deps) {
        const dep = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", projectId).eq("taskId", depId)).unique();
        if (!dep || dep.status !== "done") { initStatus = "blocked"; break; }
      }
    }

    const id = await ctx.db.insert(TABLE, {
      projectId,
      taskId: args.taskId,
      agent: args.agent,
      title: args.title,
      description: args.description,
      priority: args.priority ?? "medium",
      status: initStatus as any,
      category: args.category as any,
      phaseId: args.phaseId as any,
      wave: args.wave ?? 1,
      estimatedHours: args.estimatedHours,
      dependencies: deps,
      tags: args.tags,
      acceptanceCriteria: args.acceptanceCriteria,
      filesExpected: args.filesExpected ?? [],
      commits: [],
      statusHistory: [{ status: initStatus, timestamp: now }],
      createdAt: now,
      updatedAt: now,
    });
    return id;
  },
});

export const update = mutation({
  args: { taskId: v.string(), fields: v.any(), projectId: v.optional(v.string()) },
  handler: async (ctx, { taskId, fields, projectId }) => {
    const scope = resolveProjectId(projectId);
    const task = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId)).unique();
    if (!task) throw new Error(`Task ${taskId} not found`);
    await ctx.db.patch(task._id, { ...fields, projectId: scope, updatedAt: Date.now() });
  },
});

export const changeStatus = mutation({
  args: {
    projectId: v.optional(v.string()),
    taskId: v.string(),
    newStatus: v.string(),
    note: v.optional(v.string()),
    agent: v.optional(v.string()),
  },
  handler: async (ctx, { projectId, taskId, newStatus, note, agent }) => {
    const scope = resolveProjectId(projectId);
    const task = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId)).unique();
    if (!task) throw new Error(`Task ${taskId} not found`);
    const now = Date.now();
    const history = [...(task.statusHistory ?? []), { status: newStatus, timestamp: now, note, agent }];
    const patch: Record<string, unknown> = { status: newStatus, statusHistory: history, updatedAt: now };
    if (newStatus === "in_progress" && !task.startedAt) patch.startedAt = now;
    if (newStatus === "done") patch.completedAt = now;
    await ctx.db.patch(task._id, patch);

    // Auto-unblock dependents when done
    if (newStatus === "done") {
      const all = await ctx.db.query(TABLE).withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
      for (const t of all) {
        if (t.status !== "blocked" || !t.dependencies?.includes(taskId)) continue;
        const allMet = t.dependencies.every((d) => {
          if (d === taskId) return true;
          const dep = all.find((x) => x.taskId === d);
          return dep?.status === "done";
        });
        if (allMet) await ctx.db.patch(t._id, { status: "todo", updatedAt: now });
      }
    }

    await checkAgentOpsTriggers(ctx, scope, "status_change", { taskId, agent: task.agent, priority: task.priority, status: newStatus });
  },
});

export const addBlocker = mutation({
  args: { taskId: v.string(), reason: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { taskId, reason, projectId }) => {
    const scope = resolveProjectId(projectId);
    const task = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId)).unique();
    if (!task) throw new Error(`Task ${taskId} not found`);
    const blockers = [...(task.blockers ?? []), { reason, createdAt: Date.now() }];
    await ctx.db.patch(task._id, { blockers, status: "blocked", updatedAt: Date.now() });
  },
});

export const resolveBlocker = mutation({
  args: { taskId: v.string(), index: v.number(), projectId: v.optional(v.string()) },
  handler: async (ctx, { taskId, index, projectId }) => {
    const scope = resolveProjectId(projectId);
    const task = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId)).unique();
    if (!task) throw new Error(`Task ${taskId} not found`);
    const blockers = [...(task.blockers ?? [])];
    if (blockers[index]) blockers[index] = { ...blockers[index], resolvedAt: Date.now(), resolvedBy: "system" };
    const allResolved = blockers.every((b) => b.resolvedAt);
    await ctx.db.patch(task._id, { blockers, status: allResolved ? "todo" : "blocked", updatedAt: Date.now() });
  },
});

export const remove = mutation({
  args: { taskId: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { taskId, projectId }) => {
    const scope = resolveProjectId(projectId);
    const task = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId)).unique();
    if (!task) throw new Error(`Task ${taskId} not found`);
    await ctx.db.delete(task._id);
  },
});

export const bulkImport = mutation({
  args: { tasks: v.array(v.any()), source: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { tasks, source, projectId }) => {
    const scope = resolveProjectId(projectId);
    const now = Date.now();
    let created = 0, updated = 0;
    for (const t of tasks) {
      const existing = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", t.taskId)).unique();
      if (existing) {
        await ctx.db.patch(existing._id, { ...t, projectId: scope, updatedAt: now });
        updated++;
      } else {
        await ctx.db.insert(TABLE, { ...t, projectId: scope, createdAt: now, updatedAt: now });
        created++;
      }
    }
    await ctx.db.insert("taskSyncLog", {
      projectId: scope,
      operation: "import", source, tasksAffected: created + updated,
      tasksCreated: created, tasksUpdated: updated, timestamp: now,
    });
    return { created, updated };
  },
});

// ── Software: Commit Tracking ──

export const addCommit = mutation({
  args: {
    projectId: v.optional(v.string()),
    taskId: v.string(),
    hash: v.string(),
    message: v.string(),
    filesChanged: v.optional(v.array(v.string())),
    agent: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const scope = resolveProjectId(args.projectId);
    const task = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", args.taskId)).unique();
    if (!task) throw new Error(`Task ${args.taskId} not found`);
    const commits = [...(task.commits ?? []), {
      hash: args.hash, message: args.message, timestamp: Date.now(),
      filesChanged: args.filesChanged, agent: args.agent,
    }];
    await ctx.db.patch(task._id, { commits, updatedAt: Date.now() });
    await checkAgentOpsTriggers(ctx, scope, "commit", { taskId: args.taskId, agent: task.agent, priority: task.priority });
  },
});

export const projects = query({
  handler: async (ctx) => {
    const all = await ctx.db.query(TABLE).collect();
    return [...new Set(all.map((t) => t.projectId).filter(Boolean))].sort();
  },
});

export const stats = query({
  args: { projectId: v.optional(v.string()) },
  handler: async (ctx, { projectId }) => {
    const scope = resolveProjectId(projectId);
    const all = await ctx.db.query(TABLE).withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
    const byStatus: Record<string, number> = {};
    const byAgent: Record<string, number> = {};
    let done = 0;
    for (const t of all) {
      byStatus[t.status] = (byStatus[t.status] ?? 0) + 1;
      byAgent[t.agent] = (byAgent[t.agent] ?? 0) + 1;
      if (t.status === "done") done++;
    }
    return { total: all.length, byStatus, byAgent, done };
  },
});

export const getByTaskId = query({
  args: { taskId: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { taskId, projectId }) => {
    const scope = resolveProjectId(projectId);
    return await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId)).unique();
  },
});

export const updateNotes = mutation({
  args: { taskId: v.string(), notes: v.string(), projectId: v.optional(v.string()) },
  handler: async (ctx, { taskId, notes, projectId }) => {
    const scope = resolveProjectId(projectId);
    const task = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId)).unique();
    if (!task) throw new Error(`Task ${taskId} not found`);
    await ctx.db.patch(task._id, { notes, updatedAt: Date.now() });
  },
});

export const updateStatus = mutation({
  args: { taskId: v.string(), newStatus: v.string(), note: v.optional(v.string()), agent: v.optional(v.string()), projectId: v.optional(v.string()) },
  handler: async (ctx, { taskId, newStatus, note, agent, projectId }) => {
    const scope = resolveProjectId(projectId);
    const task = await ctx.db.query(TABLE).withIndex("by_project_taskId", (q) => q.eq("projectId", scope).eq("taskId", taskId)).unique();
    if (!task) throw new Error(`Task ${taskId} not found`);
    const now = Date.now();
    const history = [...(task.statusHistory ?? []), { status: newStatus, timestamp: now, note, agent }];
    const patch: Record<string, unknown> = { status: newStatus, statusHistory: history, updatedAt: now };
    if (newStatus === "in_progress" && !task.startedAt) patch.startedAt = now;
    if (newStatus === "done") patch.completedAt = now;
    await ctx.db.patch(task._id, patch);
    if (newStatus === "done") {
      const all = await ctx.db.query(TABLE).withIndex("by_projectId", (q) => q.eq("projectId", scope)).collect();
      for (const t of all) {
        if (t.status !== "blocked" || !t.dependencies?.includes(taskId)) continue;
        const allMet = t.dependencies.every((d) => d === taskId || all.find((x) => x.taskId === d)?.status === "done");
        if (allMet) await ctx.db.patch(t._id, { status: "todo", updatedAt: now });
      }
    }
  },
});
